Notes on signal handlers:
------------------------

Seem to be of limited value. First off the JVM apparantly uses signals such as SIGSEGV as a normal course

See "Signal Chaining': https://docs.oracle.com/javase/9/troubleshoot/handle-signals-and-exceptions.htm#JSTGD351

Using LD_PRELOAD trick in the local_run.sh launcher I can have the final SIGSEGV delivered to a handler
in the native code but this is little that can be gleaned from this point due to limitations on malloc etc
within signal handlers.

I tried backtrace() but I will receive a separate SIGSEGV from this function from within the signal handler
itself:

Core was generated by `/usr/lib/jvm/java-11-openjdk-amd64/bin/java -Djava.util.logging.config.file=exp'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007f2426b1c7ff in _Unwind_Backtrace () from /lib/x86_64-linux-gnu/libgcc_s.so.1
[Current thread is 1 (Thread 0x7f22bac75700 (LWP 544521))]
(gdb) bt
#0  0x00007f2426b1c7ff in _Unwind_Backtrace () from /lib/x86_64-linux-gnu/libgcc_s.so.1
#1  0x00007f242826f136 in __GI___backtrace (array=<optimized out>, size=<optimized out>) at backtrace.c:116
#2  0x00007f23d26b81aa in ?? ()
#3  0x0000001a00000000 in ?? ()
#4  0x0000000000000000 in ?? ()

I examined source code of backtrace in hopes of duplicating the code locally in the native and not resorting
to malloc. Unfortunately there are some dependent functions referenced directly from clib (_Unwind_Backtrace)
for supporting backtrace() that I cannot find. So this was a dead end. Interesting technique of resolving 
these functions by __libc_dlopen (LIBGCC_S_SO) && unwind_backtrace = __libc_dlsym (libgcc_handle, "_Unwind_Backtrace");

Notes on behaviour of assert:
----------------------------

Inserting an intentional assert in BRCyptoSystem.c (assert(system == NULL)) causes the following type of stack trace which is
entirely different from the stack trace I receive on crash.

Core was generated by `/usr/lib/jvm/java-11-openjdk-amd64/bin/java -Djava.util.logging.config.file=exp'.
Program terminated with signal SIGABRT, Aborted.
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
[Current thread is 1 (Thread 0x7f38173cd700 (LWP 539698))]
(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f3818a27859 in __GI_abort () at abort.c:79
#2  0x00007f3818a27729 in __assert_fail_base (fmt=0x7f3818bbd588 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=0x7f37ab114e39 "system == NULL", 
    file=0x7f37ab114c68 "/home/bryan/projects/brd/walletkit/WalletKitJava/corenative/src/main/cpp/core/src/crypto/BRCryptoSystem.c", line=347, 
    function=<optimized out>) at assert.c:92
#3  0x00007f3818a38f36 in __GI___assert_fail (assertion=0x7f37ab114e39 "system == NULL", 
    file=0x7f37ab114c68 "/home/bryan/projects/brd/walletkit/WalletKitJava/corenative/src/main/cpp/core/src/crypto/BRCryptoSystem.c", line=347, 
    function=0x7f37ab114d3d "BRCryptoSystem cryptoSystemCreate(BRCryptoClient, BRCryptoListener, BRCryptoAccount, const char *, BRCryptoBoolean)") at assert.c:101
#4  0x00007f37aafda9a8 in ?? ()
#5  0x00007f37ab180000 in ?? ()
#6  0x00007f381083c450 in ?? ()
#7  0x00007f381083c450 in ?? ()
#8  0x00007f381083c450 in ?? ()
#9  0x0000005700000000 in ?? ()
#10 0x0000000000000037 in ?? ()
#11 0x00007f38173cb810 in ?? ()
#12 0x00007f3800000009 in ?? ()
#13 0x0000000000000000 in ?? ()
(gdb) quit
bryan@Churchill:~/projects/brd/walletkit/WalletKitJava/explore$ ls

Notes on compilation with AddressSanitizer
-----------------------------------------

I thought of looking for tools that can detect typical kind of memory access
violations

I found the following https://clang.llvm.org/docs/AddressSanitizer.html and tried to
activate it. I added various compile and link flags to the corenative-jre build gradle.
Outcome was the following:

==548207==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f69a1acb780 at pc 0x7f69b58fa4b6 bp 0x7f69a1acb470 sp 0x7f69a1acb460
READ of size 8 at 0x7f69a1acb780 thread T1011 (Core BTX, )
[02-06.2:55:03.398][SEVERE][com.breadwallet.corecrypto.System] TransferCreated: missed wallet manager
[02-06.2:55:03.571][INFO][xplr-instance-133-ginger] Log instance started
    #0 0x7f69b58fa4b5  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x4254b5)
    #1 0x7f69b58ed30a  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x41830a)
    #2 0x7f6c216da608 in start_thread /build/glibc-eX1tMB/glibc-2.31/nptl/pthread_create.c:477
    #3 0x7f6c21827292 in __clone (/lib/x86_64-linux-gnu/libc.so.6+0x122292)

Address 0x7f69a1acb780 is located in stack of thread T1011 (Core BTX, ) at offset 352 in frame
    #0 0x7f69b58f977f  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x42477f)

  This frame has 6 object(s):
    [32, 160) 'addr' (line 871)
    [192, 208) 'tv' (line 872)
    [224, 352) 'fds' (line 873) <== Memory access at offset 352 overflows this variable
    [384, 388) 'optLen' (line 874)
    [400, 404) 'err' (line 875)
    [416, 420) 'on' (line 875)
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
Thread T1011 (Core BTX, ) created by T518 (pool-91-thread-) here:
    #0 0x7f6c21958805 in pthread_create (/usr/lib/gcc/x86_64-linux-gnu/9/libasan.so+0x3a805)
    #1 0x7f69b58ece4c  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x417e4c)
    #2 0x7f69b5686067  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x1b1067)
    #3 0x7f69b5670531  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x19b531)
    #4 0x7f69b573430a  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x25f30a)
    #5 0x7f69b5632b46  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x15db46)
    #6 0x7f69b6c18643  (/home/bryan/.cache/JNA/temp/jna342035324020493362.tmp+0x13643)
    #7 0x7f699b9b24cf  (<unknown module>)

Thread T518 (pool-91-thread-) created by T31 (pool-4-thread-1) here:
    #0 0x7f6c21958805 in pthread_create (/usr/lib/gcc/x86_64-linux-gnu/9/libasan.so+0x3a805)
    #1 0x7f6c1d833e75 in os::create_thread(Thread*, os::ThreadType, unsigned long) src/hotspot/os/linux/os_linux.cpp:845
    #2 0x7f6c1d566ea0 in JVM_StartThread src/hotspot/share/prims/jvm.cpp:2893
    #3 0x7f6c0522738f  (<unknown module>)
    #4 0x7f6c05221c1b  (<unknown module>)
    #5 0x7f6c05221c1b  (<unknown module>)
    #6 0x7f6c057d8d1b  (<unknown module>)
    #7 0x7f6c05fac53b  (<unknown module>)
    #8 0x7f6c05221c1b  (<unknown module>)
    #9 0x7f6c05221c60  (<unknown module>)
    #10 0x7f6c05218848  (<unknown module>)
    #11 0x7f6c1d4b85d8 in JavaCalls::call_helper(JavaValue*, methodHandle const&, JavaCallArguments*, Thread*) src/hotspot/share/runtime/javaCalls.cpp:442
    #12 0x7f6c1d4b6c2d in JavaCalls::call(JavaValue*, methodHandle const&, JavaCallArguments*, Thread*) src/hotspot/share/runtime/javaCalls.cpp:341
    #13 0x7f6c1d4b6c2d in JavaCalls::call_virtual(JavaValue*, Klass*, Symbol*, Symbol*, JavaCallArguments*, Thread*) src/hotspot/share/runtime/javaCalls.cpp:197
    #14 0x7f6c1d4b6c2d in JavaCalls::call_virtual(JavaValue*, Handle, Klass*, Symbol*, Symbol*, Thread*) src/hotspot/share/runtime/javaCalls.cpp:203
    #15 0x7f6c1d55f7d0 in thread_entry src/hotspot/share/prims/jvm.cpp:2847
    #16 0x7f6c1da78cce in JavaThread::thread_main_inner() src/hotspot/share/runtime/thread.cpp:1858
    #17 0x7f6c1da7532f in Thread::call_run() src/hotspot/share/runtime/thread.cpp:379
    #18 0x7f6c1d8336e5 in thread_native_entry src/hotspot/os/linux/os_linux.cpp:785
    #19 0x7f6c216da608 in start_thread /build/glibc-eX1tMB/glibc-2.31/nptl/pthread_create.c:477

Thread T31 (pool-4-thread-1) created by T30 here:
    #0 0x7f6c21958805 in pthread_create (/usr/lib/gcc/x86_64-linux-gnu/9/libasan.so+0x3a805)
    #1 0x7f6c1d833e75 in os::create_thread(Thread*, os::ThreadType, unsigned long) src/hotspot/os/linux/os_linux.cpp:845
    #2 0x7f6c1d566ea0 in JVM_StartThread src/hotspot/share/prims/jvm.cpp:2893
    #3 0x7f6c0522738f  (<unknown module>)
    #4 0x7f6c05221c1b  (<unknown module>)
    #5 0x7f6c05221c1b  (<unknown module>)
    #6 0x7f6c052213af  (<unknown module>)
    #7 0x7f6c05221c60  (<unknown module>)
    #8 0x7f6c05221c60  (<unknown module>)
    #9 0x7f6c05221c1b  (<unknown module>)
    #10 0x7f6c05221c60  (<unknown module>)
    #11 0x7f6c05218848  (<unknown module>)
    #12 0x7f6c1d4b85d8 in JavaCalls::call_helper(JavaValue*, methodHandle const&, JavaCallArguments*, Thread*) src/hotspot/share/runtime/javaCalls.cpp:442
    #13 0x7f6c1d533bf8 in jni_invoke_nonstatic src/hotspot/share/prims/jni.cpp:1184
    #14 0x7f6c1d5360c9 in jni_CallVoidMethod src/hotspot/share/prims/jni.cpp:1569
    #15 0x7f69b6c18643  (/home/bryan/.cache/JNA/temp/jna342035324020493362.tmp+0x13643)
    #16 0x7f69b4f16d9f  (<unknown module>)

Thread T30 created by T1 here:
    #0 0x7f6c21958805 in pthread_create (/usr/lib/gcc/x86_64-linux-gnu/9/libasan.so+0x3a805)
    #1 0x7f69b598ab16  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x4b5b16)
    #2 0x7f69b56aaf02  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x1d5f02)
    #3 0x7f69b58b5832  (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x3e0832)
    #4 0x7f69b6c18643  (/home/bryan/.cache/JNA/temp/jna342035324020493362.tmp+0x13643)
    #5 0x7f6c1ca7e55f  (<unknown module>)

Thread T1 created by T0 here:
    #0 0x7f6c21958805 in pthread_create (/usr/lib/gcc/x86_64-linux-gnu/9/libasan.so+0x3a805)
    #1 0x7f6c2191594a in ContinueInNewThread0 src/java.base/unix/native/libjli/java_md_solinux.c:760
    #2 0x7f6c21911e45 in ContinueInNewThread src/java.base/share/native/libjli/java.c:2354
    #3 0x7f6c21913739 in JLI_Launch src/java.base/share/native/libjli/java.c:341
    #4 0x559316d2c2b2 in main src/java.base/share/native/launcher/main.c:206
    #5 0x7f6c2172c0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)

SUMMARY: AddressSanitizer: stack-buffer-overflow (/home/bryan/.cache/JNA/temp/jna4724415578894660483.tmp+0x4254b5) 
Shadow bytes around the buggy address:
  0x0fedb43516a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0fedb43516b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0fedb43516c0: 00 00 00 00 f1 f1 f1 f1 00 00 00 00 00 00 00 00
  0x0fedb43516d0: 00 00 00 00 00 00 00 00 f2 f2 f2 f2 00 00 f2 f2
  0x0fedb43516e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x0fedb43516f0:[f2]f2 f2 f2 04 f2 04 f2 04 f3 f3 f3 00 00 00 00
  0x0fedb4351700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0fedb4351710: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0fedb4351720: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0fedb4351730: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0fedb4351740: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc

The stack-buffer-overflow above seems related to sock id > FD_SETSIZE as mentioned in https://linux.die.net/man/3/fd_set.
It would happen pretty reliably after 128 instances.

I put an assert(sock < 1024) in the code and it raised this assert:

[02-06.4:31:57.538][INFO][xplr-com.breadwallet.crypto.explore.Main] 128) SystemInstance: instance-129-ginger
[02-06.4:31:57.540][INFO][xplr-instance-62-ginger] Connecting wallet manager: bsv balance BSV25.89882 (BSV)
java: /home/bryan/projects/brd/walletkit/WalletKitJava/corenative/src/main/cpp/core/src/bitcoin/BRPeer.c:880: int _BRPeerOpenSocket(BRPeer *, int, double, int *): Assertion `sock < 1024' failed.
Aborted (core dumped)

There are claims I read that simple close() of socket is not sufficient to close and allow reuse of socket descriptor.

I used ss -tp to display socket descriptors on the system when the application (PID: 564198) was running, I can see the file descriptor getting close to 
upper limit in below before the assert sock < 1024 kicks in:

ESTAB          181             0                        [::ffff:192.168.1.152]:60336                    [::ffff:165.227.37.47]:18333                 users:(("java",pid=564198,fd=1002))                  
ESTAB          0               0                        [::ffff:192.168.1.152]:33826                    [::ffff:157.230.96.95]:18333                 users:(("java",pid=564198,fd=442))                   
ESTAB          0               0                        [::ffff:192.168.1.152]:34020                    [::ffff:157.230.96.95]:18333                 users:(("java",pid=564198,fd=716))                   
ESTAB          1430            0                        [::ffff:192.168.1.152]:59908                    [::ffff:165.227.37.47]:18333                 users:(("java",pid=564198,fd=433))      

Final notes:
------------

After the FD_SET issue is corrected I managed to acheive 486 instances but then receive this error:

CRY: FileService Error: disk I/O error
CRY: FileService Error: FORCED SYNC

I deleted all dbs. And re-ran and seeing another sanitizer issue captured in sanitizer_deadly_signal_system_instance_360.txt

 
